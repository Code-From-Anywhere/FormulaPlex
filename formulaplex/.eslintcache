[{"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/App.tsx":"1","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Selectors.tsx":"2","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Container.tsx":"3","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Toolbar.tsx":"4","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Sidebar.tsx":"5","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/ActionTypes.tsx":"6","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Actions.tsx":"7","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Windows.tsx":"8","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/index.js":"9","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Components/Smart/Piano.tsx":"10","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Store.tsx":"11","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Types/Types.tsx":"12","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Util/Util.ts":"13"},{"size":25121,"mtime":1608226830202,"results":"14","hashOfConfig":"15"},{"size":2204,"mtime":1608241451209,"results":"16","hashOfConfig":"15"},{"size":1055,"mtime":1608229683838,"results":"17","hashOfConfig":"15"},{"size":2359,"mtime":1608240632094,"results":"18","hashOfConfig":"15"},{"size":13038,"mtime":1608239817355,"results":"19","hashOfConfig":"15"},{"size":421,"mtime":1608240523210,"results":"20","hashOfConfig":"15"},{"size":2554,"mtime":1608240525217,"results":"21","hashOfConfig":"15"},{"size":1369,"mtime":1608237271334,"results":"22","hashOfConfig":"15"},{"size":500,"mtime":1608054282291,"results":"23","hashOfConfig":"15"},{"size":8504,"mtime":1608239996301,"results":"24","hashOfConfig":"15"},{"size":916,"mtime":1608236368776,"results":"25","hashOfConfig":"15"},{"size":12796,"mtime":1608239857537,"results":"26","hashOfConfig":"15"},{"size":3901,"mtime":1608239938606,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1mzw3x3",{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"51"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/App.tsx",["58","59","60","61","62"],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Selectors.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Container.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Toolbar.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Sidebar.tsx",["63","64","65","66","67"],"import { useRef } from \"react\";\nimport { AiFillDelete } from \"react-icons/ai\";\nimport { BiPlay } from \"react-icons/bi\";\nimport { BsStopFill } from \"react-icons/bs\";\nimport { IoMdAdd } from \"react-icons/io\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport * as Tone from \"tone\";\nimport ColorBadge from \"../Components/Dumb/ColorBadge\";\nimport {\n  actionSetCurrentSynth,\n  actionSetInstruments,\n  actionSetMelodies,\n  actionSetPatternPlayers,\n  actionSetPatterns,\n  actionSetSelectedInstrumentId,\n  actionSetSelectedMelodyId,\n  actionSetSelectedPatternId,\n  actionSetSelectedTimedMelodyId,\n  actionSetTimedMelodies,\n} from \"../Context/Actions\";\nimport {\n  selectCurrentSynth,\n  selectInstruments,\n  selectMelodies,\n  selectPatternPlayers,\n  selectPatterns,\n  selectProjectPitch,\n  selectSelectedInstrumentId,\n  selectSelectedMelodyId,\n  selectSelectedPatternId,\n  selectSelectedTimedMelodyId,\n  selectTimedMelodies,\n} from \"../Context/Selectors\";\nimport Style from \"../Style/Style\";\nimport {\n  defaultSynthOptions,\n  Instrument,\n  Melody,\n  Pattern,\n  PatternPlayer,\n  PatternPlayersPerPattern,\n  Sample,\n  SynthTypes,\n  synthTypes,\n  TimedMelody,\n} from \"../Types/Types\";\nimport {\n  Constants,\n  generateColor,\n  generateId,\n  generatePatternPlayerArray,\n  generateSynth,\n  startPlayPattern,\n} from \"../Util/Util\";\n\nconst Sidebar = () => {\n  const selectInstrumentRef = useRef<HTMLSelectElement | null>(null);\n\n  const dispatch = useDispatch();\n\n  const currentSynth = useSelector(selectCurrentSynth);\n  const setCurrentSynth = (sample: Sample) =>\n    dispatch(actionSetCurrentSynth(sample));\n  const setInstruments = (instruments: Instrument[]) =>\n    dispatch(actionSetInstruments(instruments));\n\n  const instruments = useSelector(selectInstruments);\n\n  const setTimedMelodies = (timedMelodies: TimedMelody[]) =>\n    dispatch(actionSetTimedMelodies(timedMelodies));\n\n  const projectPitch = useSelector(selectProjectPitch);\n  const setPatternPlayers = (patternPlayers: PatternPlayersPerPattern) =>\n    dispatch(actionSetPatternPlayers(patternPlayers));\n\n  const setPatterns = (patterns: Pattern[]) =>\n    dispatch(actionSetPatterns(patterns));\n\n  const setSelectedMelodyId = (id: string | null) =>\n    dispatch(actionSetSelectedMelodyId(id));\n\n  const setSelectedTimedMelodyId = (id: string | null) =>\n    dispatch(actionSetSelectedTimedMelodyId(id));\n\n  const setSelectedPatternId = (id: string | null) =>\n    dispatch(actionSetSelectedPatternId(id));\n\n  const setSelectedInstrumentId = (id: string | null) =>\n    dispatch(actionSetSelectedInstrumentId(id));\n\n  const setMelodies = (melodies: Melody[]) =>\n    dispatch(actionSetMelodies(melodies));\n  const timedMelodies = useSelector(selectTimedMelodies);\n  const melodies = useSelector(selectMelodies);\n  const patterns = useSelector(selectPatterns);\n  const selectedInstrumentId = useSelector(selectSelectedInstrumentId);\n  const selectedPatternId = useSelector(selectSelectedPatternId);\n  const selectedMelodyId = useSelector(selectSelectedMelodyId);\n  const selectedTimedMelodyId = useSelector(selectSelectedTimedMelodyId);\n  const patternPlayers = useSelector(selectPatternPlayers);\n\n  const newInstrument = (soundString: SynthTypes) => {\n    const defaults = defaultSynthOptions[soundString];\n    const synth = generateSynth(soundString, defaults);\n\n    currentSynth.sample.dispose();\n    setCurrentSynth({ sample: synth, type: soundString });\n\n    const newInstrument: Instrument = {\n      id: generateId(),\n      type: soundString,\n      name: null,\n      color: generateColor(),\n      properties: defaults,\n    };\n\n    setInstruments([...instruments, newInstrument]);\n  };\n\n  const addTimedMelody = (melody: Melody) => {\n    const newTimedMelody: TimedMelody = {\n      defaultDuration: 1,\n      pitch: 4,\n      id: generateId(),\n      color: generateColor(),\n      melodyId: melody.id,\n      name: null,\n      timedMelody: melody.melody.map((key, index) => ({\n        ...key,\n        startPosition: index,\n      })),\n    };\n\n    setTimedMelodies([...timedMelodies, newTimedMelody]);\n  };\n\n  const renderMelodies = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Melodies:</p>\n\n      {melodies.map((melody, index) => {\n        const filteredTimedMelodies = timedMelodies.filter(\n          (t) => t.melodyId === melody.id\n        );\n\n        const isSelected = selectedMelodyId === melody.id;\n        return (\n          <div>\n            <div\n              onClick={() => {\n                setSelectedMelodyId(isSelected ? null : melody.id);\n              }}\n              style={{\n                border: isSelected ? \"1px dotted black\" : undefined,\n                borderRadius: 3,\n                padding: 3,\n              }}\n            >\n              {melody.name || `Melody ${index}`}\n              <BiPlay\n                size={Constants.ICON_SIZE}\n                onClick={async () => {\n                  // for (const { note, modifier } of melody.melody) {\n                  //   setCurrentKey({ note, modifier });\n                  //   await timeout(250);\n                  //   setCurrentKey(null);\n                  //   await timeout(250);\n                  // }\n                  //do this with Tone.Transport\n                }}\n              />\n              <AiFillDelete\n                size={Constants.ICON_SIZE}\n                onClick={() => {\n                  setMelodies(melodies.filter((melody, i) => i !== index));\n                }}\n              />\n\n              <IoMdAdd\n                size={Constants.ICON_SIZE}\n                onClick={() => {\n                  addTimedMelody(melody);\n                }}\n              />\n            </div>\n            {filteredTimedMelodies && (\n              <div>\n                {filteredTimedMelodies.map((timedMelody, index) => {\n                  const isSelected = timedMelody.id === selectedTimedMelodyId;\n                  return (\n                    <div\n                      key={`${timedMelody.id}timedMelody`}\n                      onClick={() =>\n                        selectedTimedMelodyId === timedMelody.id\n                          ? setSelectedTimedMelodyId(null)\n                          : setSelectedTimedMelodyId(timedMelody.id)\n                      }\n                      style={{\n                        border: isSelected ? \"1px dotted black\" : undefined,\n                        borderRadius: 3,\n                        padding: 3,\n                        marginLeft: 20,\n                      }}\n                    >\n                      {timedMelody.name || `Timed melody ${index}`}\n\n                      <BiPlay\n                        size={Constants.ICON_SIZE}\n                        onClick={async () => {\n                          for (const {\n                            note,\n                            modifier,\n                            duration,\n                            startPosition,\n                          } of timedMelody.timedMelody) {\n                            // Make Tone.Transport that plays the melody in a loop\n                            // setCurrentKey({ note, modifier });\n                            // await timeout(\n                            //   duration !== undefined\n                            //     ? duration\n                            //     : timedMelody.defaultDuration\n                            // );\n                            // setCurrentKey(null);\n                            // await timeout(\n                            //   pauseEnd !== undefined\n                            //     ? pauseEnd\n                            //     : timedMelody.defaultPause\n                            // );\n                          }\n                        }}\n                      />\n                      <AiFillDelete\n                        size={Constants.ICON_SIZE}\n                        onClick={() => {\n                          setSelectedTimedMelodyId(null);\n                          setTimedMelodies(\n                            timedMelodies.filter((t, i) => i !== index)\n                          );\n                        }}\n                      />\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n  const renderRythms = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Rythms:</p>\n      <p>\n        Coming soon. Rythms are songs to automatically generate TimedMelodies\n      </p>\n    </div>\n  );\n\n  const renderPatterns = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Patterns:</p>\n      {patterns.map((pattern) => {\n        const isSelected = pattern.id === selectedPatternId;\n        const ourPatternPlayer = !!patternPlayers[pattern.id];\n        return (\n          <div\n            onClick={() => setSelectedPatternId(pattern.id)}\n            key={`pattern${pattern.id}`}\n            style={Style.itemStyle(isSelected)}\n          >\n            {pattern.name}{\" \"}\n            {ourPatternPlayer ? (\n              <BsStopFill\n                key={`stopIcon${pattern.id}${ourPatternPlayer}`}\n                size={Constants.ICON_SIZE}\n                onClick={() => {\n                  // always first stop before diposing.\n                  Tone.Transport.stop(0);\n                  patternPlayers[pattern.id]?.map((patternPlayer) => {\n                    patternPlayer.sample.dispose();\n                  });\n\n                  const newPatternPlayers = { ...patternPlayers }; //NB: Make sure dat dit geen memory leak veroorzaakt\n                  delete newPatternPlayers[pattern.id];\n\n                  console.log(\"newPatternPlayers\", newPatternPlayers);\n                  setPatternPlayers(newPatternPlayers);\n                }}\n              />\n            ) : (\n              <BiPlay\n                key={`playIcon${pattern.id}${ourPatternPlayer}`}\n                size={Constants.ICON_SIZE}\n                onClick={() => {\n                  if (projectPitch) {\n                    const patternPlayerArray = generatePatternPlayerArray(\n                      pattern.channels,\n                      instruments,\n                      timedMelodies\n                    );\n                    const array = patternPlayerArray as PatternPlayer[];\n                    setPatternPlayers({\n                      ...patternPlayers,\n                      [pattern.id]: array,\n                    });\n                    startPlayPattern(array, projectPitch, 1, true);\n                  }\n                }}\n              />\n            )}\n            <AiFillDelete\n              size={Constants.ICON_SIZE}\n              onClick={() => {\n                setPatterns(patterns.filter((f) => f.id !== pattern.id));\n              }}\n            />\n          </div>\n        );\n      })}\n    </div>\n  );\n\n  const renderSongs = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Songs:</p>\n      <p>Coming soon. Formulas are a combination of patterns on a timeline.</p>\n    </div>\n  );\n\n  const renderCompositions = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Compositions:</p>\n      <p>\n        Coming soon. Compositions are the grammar of a song, the underlying\n        structure. Compositions can be used to automatically generate songs.\n      </p>\n    </div>\n  );\n\n  const renderInstruments = (\n    <div>\n      <p style={{ fontWeight: \"bold\" }}>Instruments:</p>\n\n      <select\n        ref={selectInstrumentRef}\n        onChange={(e) => {\n          if (e.target.value !== \"new\") {\n            newInstrument(e.target.value as SynthTypes);\n            if (selectInstrumentRef.current) {\n              selectInstrumentRef.current.value = \"new\";\n            }\n          }\n        }}\n      >\n        <option value=\"new\">New</option>\n        {synthTypes.map((type) => (\n          <option key={`selectSynth${type}`} value={type}>\n            {type}\n          </option>\n        ))}\n      </select>\n      {instruments.map((instrument, index) => {\n        const isSelected = selectedInstrumentId === instrument.id;\n        return (\n          <div\n            key={`instrument${index}`}\n            onClick={() => {\n              setSelectedInstrumentId(instrument.id);\n              currentSynth.sample.dispose();\n\n              setCurrentSynth({\n                sample: generateSynth(instrument.type, instrument.properties),\n                type: instrument.type,\n              });\n            }}\n            style={Style.itemStyle(isSelected)}\n          >\n            <ColorBadge color={instrument.color} />\n\n            {instrument.name || `Instrument ${index}`}\n            <AiFillDelete\n              size={Constants.ICON_SIZE}\n              onClick={() => {\n                setInstruments(\n                  instruments.filter((p) => p.id !== instrument.id)\n                );\n              }}\n            />\n          </div>\n        );\n      })}\n    </div>\n  );\n  return (\n    <div>\n      {renderMelodies}\n      {renderRythms}\n      {renderCompositions}\n      {renderInstruments}\n      {renderPatterns}\n      {renderSongs}\n    </div>\n  );\n};\n\nexport default Sidebar;\n","/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/ActionTypes.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Actions.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Layout/Windows.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/index.js",[],["68","69"],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Components/Smart/Piano.tsx",["70","71"],"import { useEffect, useRef } from \"react\";\nimport { useHotkeys } from \"react-hotkeys-hook\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport * as Tone from \"tone\";\nimport {\n  actionSetCurrentKeys,\n  actionSetProject,\n  actionSetRecordingMelody,\n} from \"../../Context/Actions\";\nimport {\n  selectCurrentKeys,\n  selectCurrentSynth,\n  selectIsRecordingMelody,\n  selectProjectPitch,\n  selectRecordingMelody,\n} from \"../../Context/Selectors\";\n//create a synth and connect it to the main output (your speakers)\nimport { Key, Melody, Note } from \"../../Types/Types\";\nimport { Constants, generateColor, modifyPitch } from \"../../Util/Util\";\nconst baseNotes = [\"c\", \"d\", \"e\", \"f\", \"g\", \"a\", \"b\"];\nconst modifiers = [\"..\", \".\", \"\", \"^\", \"*\"];\n\nconst generateId = () => \"id\" + Math.round(Math.random() * 9999999999999);\n\nconst generateNewMelody = (firstKey: Key): Melody => ({\n  name: null,\n  id: generateId(),\n  color: generateColor(),\n  melody: [{ note: firstKey.note, modifier: firstKey.modifier }],\n});\n\nconst Piano = () => {\n  const dispatch = useDispatch();\n  const currentSynth = useSelector(selectCurrentSynth);\n  const isRecordingMelody = useSelector(selectIsRecordingMelody);\n  const recordingMelody = useSelector(selectRecordingMelody);\n  const currentKeys = useSelector(selectCurrentKeys);\n  const projectPitch = useSelector(selectProjectPitch);\n  const setRecordingMelody = (melody: Melody) =>\n    dispatch(actionSetRecordingMelody(melody));\n\n  const setCurrentKeys = (currentKeys: Key[]) =>\n    dispatch(actionSetCurrentKeys(currentKeys));\n  const setPitch = (pitch: number) =>\n    dispatch(actionSetProject(\"pitch\", pitch));\n\n  useHotkeys(\"=\", () => {\n    setPitch(\n      projectPitch && projectPitch >= Constants.MAXIMUM_PITCH\n        ? Constants.MAXIMUM_PITCH\n        : projectPitch\n        ? projectPitch + 1\n        : Constants.DEFAULT_PITCH\n    );\n  });\n  useHotkeys(\"-\", () => {\n    setPitch(\n      projectPitch && projectPitch <= Constants.MINIMAL_PITCH\n        ? Constants.MINIMAL_PITCH\n        : projectPitch\n        ? projectPitch - 1\n        : Constants.DEFAULT_PITCH\n    );\n  });\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", (event) => {\n      // const shift = event.shiftKey;\n      // const ctrl = event.ctrlKey;\n      // const alt = event.altKey;\n      // const cmd = event.metaKey;\n\n      if (baseNotes.includes(event.key.toLowerCase())) {\n        if (!currentKeys.find((x) => x.note === event.key)) {\n          setCurrentKeys([...currentKeys, { note: event.key, modifier: \"\" }]);\n        }\n      }\n    });\n\n    window.addEventListener(\"keyup\", (event) => {\n      setCurrentKeys(currentKeys.filter((x) => x.note !== event.key));\n    });\n  }, []);\n\n  useEffect(() => {\n    if (currentKeys && projectPitch) {\n      if (isRecordingMelody) {\n        setRecordingMelody(\n          recordingMelody\n            ? {\n                ...recordingMelody,\n                melody: [...recordingMelody.melody, currentKeys[0]],\n              }\n            : generateNewMelody(currentKeys[0])\n        );\n      }\n\n      const modifiedPitch = modifyPitch(projectPitch, currentKeys[0].modifier);\n\n      const convertedKeyPitchCombination: Note = `${currentKeys[0].note}${modifiedPitch}` as Note;\n\n      currentSynth.sample.triggerAttack(\n        convertedKeyPitchCombination,\n        Tone.context.currentTime\n      );\n    } else {\n      currentSynth.sample.triggerRelease();\n    }\n  }, [\n    currentKeys,\n    // pitch,\n    // sample,\n    // currentMelody,\n    // isRecordingMelody,\n    // setCurrentMelody,\n  ]);\n\n  const pianoContainer = useRef<HTMLDivElement | null>(null);\n\n  return (\n    <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n      <div\n        style={{\n          overflowX: \"scroll\",\n          whiteSpace: \"nowrap\",\n          height: \"20vh\",\n        }}\n        ref={pianoContainer}\n      >\n        <div\n          style={{\n            position: \"relative\",\n            display: \"flex\",\n            flexDirection: \"row\",\n            height: \"100%\",\n            width: 50 * modifiers.length * baseNotes.length,\n          }}\n        >\n          {modifiers.map((modifier, modifierIndex) =>\n            baseNotes\n              .map((note) => ({ note: `${note}#`, modifier }))\n              .map((note, index) => {\n                const midNote = note.note;\n\n                if (index === baseNotes.length - 1 || midNote === \"e#\")\n                  return null; //don't exist\n                return (\n                  <div\n                    key={`midKey${note.note}${note.modifier}`}\n                    onMouseDown={() =>\n                      setCurrentKeys([\n                        ...currentKeys,\n                        { note: midNote, modifier: note.modifier },\n                      ])\n                    }\n                    onMouseUp={() =>\n                      setCurrentKeys(\n                        currentKeys.filter(\n                          (x) =>\n                            x.note === midNote && x.modifier === note.modifier\n                        )\n                      )\n                    }\n                    style={{\n                      position: \"absolute\",\n                      top: 0,\n                      left:\n                        35 + 50 * index + 50 * modifierIndex * baseNotes.length,\n                      width: 30,\n                      height: 100,\n                      backgroundColor: currentKeys.find(\n                        (x) =>\n                          x.note === midNote && x.modifier === note.modifier\n                      )\n                        ? \"#404040\"\n                        : \"black\",\n                    }}\n                  >\n                    <p style={{ color: \"white\", fontWeight: \"bold\" }}>\n                      {midNote}\n                      {note.modifier}\n                    </p>\n                  </div>\n                );\n              })\n          )}\n          {modifiers.map((modifier) =>\n            baseNotes\n              .map((note) => ({ note, modifier }))\n              .map(({ note, modifier }) => {\n                const extraNote =\n                  note === \"f\"\n                    ? \"e#\"\n                    : note === \"c\"\n                    ? \"b#\"\n                    : note === \"b\"\n                    ? \"Cb\"\n                    : null;\n                const extraNoteModified = extraNote\n                  ? `(${extraNote}${modifier})`\n                  : null;\n\n                const isKeySelected = !!currentKeys.find(\n                  (x) => x.modifier === modifier && x.note === note\n                );\n\n                return (\n                  <div\n                    key={`key${note}${modifier}`}\n                    onMouseDown={() =>\n                      setCurrentKeys([...currentKeys, { note, modifier }])\n                    }\n                    onMouseUp={() =>\n                      setCurrentKeys(\n                        currentKeys.filter(\n                          (x) => x.note !== note && x.modifier !== modifier\n                        )\n                      )\n                    }\n                    style={{\n                      backgroundColor: isKeySelected ? \"#CCC\" : \"white\",\n                      borderWidth: \"1px\",\n                      borderColor: \"black\",\n                      borderStyle: \"solid\",\n                      boxSizing: \"border-box\",\n                      width: \"50px\",\n                      alignItems: \"center\",\n                      justifyContent: \"flex-end\",\n                      display: \"flex\",\n                      flexDirection: \"column\",\n                    }}\n                  >\n                    <p style={{ color: \"black\", fontWeight: \"bold\" }}>\n                      {note}\n                      {modifier}\n                    </p>\n\n                    {extraNoteModified && (\n                      <div>\n                        <p style={{ color: \"black\", fontWeight: \"bold\" }}>\n                          {extraNoteModified}\n                        </p>\n                      </div>\n                    )}\n                  </div>\n                );\n              })\n          )}\n        </div>\n      </div>\n      <div style={{ width: 300, backgroundColor: \"#DDD\" }}>\n        <p style={{ fontSize: 24 }}>\n          {currentKeys.map((key) => {\n            return `${key?.note} ${modifyPitch(\n              projectPitch || Constants.DEFAULT_PITCH,\n              key?.modifier\n            )}`;\n          })}\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default Piano;\n",["72","73"],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Context/Store.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Types/Types.tsx",[],"/Users/wijnandkarsens/Documents/Tone.js/formulaplex/src/Util/Util.ts",[],{"ruleId":"74","severity":1,"message":"75","line":233,"column":29,"nodeType":"76","messageId":"77","endLine":233,"endColumn":33},{"ruleId":"74","severity":1,"message":"78","line":234,"column":29,"nodeType":"76","messageId":"77","endLine":234,"endColumn":37},{"ruleId":"74","severity":1,"message":"79","line":235,"column":29,"nodeType":"76","messageId":"77","endLine":235,"endColumn":37},{"ruleId":"74","severity":1,"message":"80","line":236,"column":29,"nodeType":"76","messageId":"77","endLine":236,"endColumn":42},{"ruleId":"81","severity":1,"message":"82","line":644,"column":67,"nodeType":"83","messageId":"84","endLine":644,"endColumn":69},{"ruleId":"74","severity":1,"message":"75","line":211,"column":29,"nodeType":"76","messageId":"77","endLine":211,"endColumn":33},{"ruleId":"74","severity":1,"message":"78","line":212,"column":29,"nodeType":"76","messageId":"77","endLine":212,"endColumn":37},{"ruleId":"74","severity":1,"message":"79","line":213,"column":29,"nodeType":"76","messageId":"77","endLine":213,"endColumn":37},{"ruleId":"74","severity":1,"message":"80","line":214,"column":29,"nodeType":"76","messageId":"77","endLine":214,"endColumn":42},{"ruleId":"81","severity":1,"message":"82","line":280,"column":67,"nodeType":"83","messageId":"84","endLine":280,"endColumn":69},{"ruleId":"85","replacedBy":"86"},{"ruleId":"87","replacedBy":"88"},{"ruleId":"89","severity":1,"message":"90","line":83,"column":6,"nodeType":"91","endLine":83,"endColumn":8,"suggestions":"92"},{"ruleId":"89","severity":1,"message":"93","line":109,"column":6,"nodeType":"91","endLine":116,"endColumn":4,"suggestions":"94"},{"ruleId":"85","replacedBy":"86"},{"ruleId":"87","replacedBy":"88"},"@typescript-eslint/no-unused-vars","'note' is assigned a value but never used.","Identifier","unusedVar","'modifier' is assigned a value but never used.","'duration' is assigned a value but never used.","'startPosition' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-native-reassign",["95"],"no-negated-in-lhs",["96"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'currentKeys' and 'setCurrentKeys'. Either include them or remove the dependency array.","ArrayExpression",["97"],"React Hook useEffect has missing dependencies: 'currentSynth.sample', 'isRecordingMelody', 'projectPitch', 'recordingMelody', and 'setRecordingMelody'. Either include them or remove the dependency array.",["98"],"no-global-assign","no-unsafe-negation",{"desc":"99","fix":"100"},{"desc":"101","fix":"102"},"Update the dependencies array to be: [currentKeys, setCurrentKeys]",{"range":"103","text":"104"},"Update the dependencies array to be: [currentKeys, currentSynth.sample, isRecordingMelody, projectPitch, recordingMelody, setRecordingMelody]",{"range":"105","text":"106"},[2689,2691],"[currentKeys, setCurrentKeys]",[3414,3538],"[currentKeys, currentSynth.sample, isRecordingMelody, projectPitch, recordingMelody, setRecordingMelody]"]